<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tandemrepeats.repeat.repeat_pvalue &mdash; TRAL 0.3.3 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/tral.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="TRAL 0.3.3 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700|Source+Code+Pro|Armata|IM+Fell+English'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
  <body>
<div class="pageheader">
    <a href="http://www.isb-sib.ch/" class="sib_logo" title="SIB Swiss Institute of Bioinformatics"><img src="../../../_static/sib.png" alt="SIB" class="sib_logo" /></a>
    <a href="../../../index.html">
      <img class="headlogo" src="../../../_static/trallogo.png" alt="TRAL" />
      <span class="headlogo">Tandem Repeat Annotation Library</span>
    </a>
    <div class="headlinks">
        <a href="../../../index.html">Home</a>
        <a href="../../../installation.html">Install</a>
        <a href="../../../code_docs.html">Code docs</a>
    </div>
</div>


      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for tandemrepeats.repeat.repeat_pvalue</h1><div class="highlight"><pre>
<span class="c"># (C) 2014 Elke Schaper</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span><span class="o">,</span> <span class="nn">scipy.special</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">tandemrepeats.paths</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">path_score</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">DATAROOT</span><span class="p">,</span> <span class="s">&#39;pValue&#39;</span><span class="p">)</span>

<span class="c">########################## REPEAT SCORE P-VALUE CALCULATION FUNCTIONS ####################</span>

<span class="c">##################### phylo &amp; entropy ############################</span>

<div class="viewcode-block" id="empiricalList"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.empiricalList">[docs]</a><span class="k">def</span> <span class="nf">empiricalList</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">sequence_type</span> <span class="o">=</span> <span class="s">&#39;AA&#39;</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="s">&#39;phylo&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Load and return a numpy list with 10,000 empirical values of the user defined</span>
<span class="sd">        distribution from an external file.</span>


<span class="sd">    If no distribution is available for a given ``l`` and ``n``, the closest values for</span>
<span class="sd">    ``l`` and ``n`` are chosen instead.</span>

<span class="sd">    For the standard model score &quot;phylo&quot;, currently values are available until</span>

<span class="sd">        * ``lMax`` = 99</span>
<span class="sd">        * ``nMax`` = 49</span>
<span class="sd">        * ``totalRepeatLengthMax`` = 1000</span>

<span class="sd">    For ``l`` &lt;=  ``lMax`` and ``n`` &lt;=  ``nMax`` and ``n*l`` &lt;=  ``totalRepeatLengthMax``</span>
<span class="sd">    all values are available.</span>

<span class="sd">    For other values, we use the closest distribution, assuming that values change little</span>
<span class="sd">    (heuristic assumption!).</span>

<span class="sd">    Args:</span>
<span class="sd">        l (int): The length of the repeat unit.</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>
<span class="sd">        score: The model of repeat evolution used. E.g. &quot;phylo&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy list of length 10.000</span>


<span class="sd">    .. todo:: Define &quot;phylo&quot; model.</span>
<span class="sd">    .. todo:: Perhaps add distributions beyond lMax, nMax.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">lMax</span> <span class="o">=</span> <span class="mi">99</span>
    <span class="n">nMax</span> <span class="o">=</span> <span class="mi">49</span>
    <span class="k">if</span> <span class="n">score</span> <span class="o">==</span> <span class="s">&#39;entropy&#39;</span><span class="p">:</span>
        <span class="n">lMax</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="n">nMax</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">totalRepeatLengthMax</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">lMax</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nMax</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span><span class="o">*</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">totalRepeatLengthMax</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;l: </span><span class="si">%d</span><span class="s"> and n: </span><span class="si">%d</span><span class="s"> are bigger than the totalRepeatLengthMax: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">totalRepeatLengthMax</span><span class="p">))</span>
        <span class="c">## Dirty little hack: as we do not have data for this pair of l and n, apply nearest data file.</span>
        <span class="k">while</span> <span class="n">l</span><span class="o">*</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">totalRepeatLengthMax</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">&gt;</span><span class="n">n</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="nb">file</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">path_score</span><span class="p">,</span> <span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.npz&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="nb">file</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;complete pdf file </span><span class="si">%s</span><span class="s"> does not exist!&quot;</span> <span class="o">%</span> <span class="nb">file</span><span class="p">)</span>

    <span class="n">myEmpiricalList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
    <span class="c">## It is absolutely necessary to close the numpy filehandle.</span>
    <span class="c">## Otherwise, you will have too many open operating system filehandles</span>
    <span class="c">## if you run this function many times (more than ulimit -n allows, that is)</span>
    <span class="n">empiricalList</span> <span class="o">=</span> <span class="n">myEmpiricalList</span><span class="p">[</span><span class="s">&#39;arr_0&#39;</span><span class="p">]</span>
    <span class="n">myEmpiricalList</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">empiricalList</span>
</div>
<div class="viewcode-block" id="pValueFromEmpiricialList"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.pValueFromEmpiricialList">[docs]</a><span class="k">def</span> <span class="nf">pValueFromEmpiricialList</span><span class="p">(</span><span class="n">myTR</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="s">&#39;phylo&#39;</span><span class="p">,</span> <span class="n">myScore</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">empirical</span> <span class="o">=</span> <span class="p">[]):</span>

    <span class="sd">&quot;&quot;&quot;Calculates the p-Value of a score for the given myTR.</span>


<span class="sd">    The p-Value is the number of scores for comparable tandem repeats, i.e. of same</span>
<span class="sd">    repeat unit length and repeat unit copy number that are as good or better.</span>

<span class="sd">    Args:</span>
<span class="sd">        myTR (Repeat): An instance of the Repeat class.</span>
<span class="sd">        score: The model of repeat evolution used. E.g. &quot;phylo&quot;.</span>
<span class="sd">        myScore (float): The value of the score of the Repeat instance.</span>
<span class="sd">        empirical: The null distribution of the score for repeats of the same type.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pValue: A float.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">myScore</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">myScore</span> <span class="o">=</span> <span class="n">myTR</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">empirical</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">empirical</span> <span class="o">=</span> <span class="n">empiricalList</span><span class="p">(</span><span class="n">myTR</span><span class="o">.</span><span class="n">lD</span><span class="p">,</span> <span class="n">myTR</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">myTR</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">score</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;entropy&#39;</span><span class="p">]:</span> <span class="c"># A smaller score is a better score for all scores in this list.</span>
        <span class="k">if</span> <span class="n">myScore</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">empirical</span><span class="p">,</span> <span class="n">myScore</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">empirical</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">empirical</span><span class="p">,</span> <span class="n">myScore</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">empirical</span><span class="p">)</span>



<span class="c">########################### pSim &amp; parsimony: read in PDF ###########################</span>
</div>
<div class="viewcode-block" id="columnPDF"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.columnPDF">[docs]</a><span class="k">def</span> <span class="nf">columnPDF</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="s">&#39;psim&#39;</span><span class="p">,</span> <span class="n">sequence_type</span> <span class="o">=</span> <span class="s">&#39;AA&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Load and return the probability density function of the score on random</span>
<span class="sd">        ``sequence_type`` data of length ``n``.</span>

<span class="sd">    Load and return the probability density function of the score on random</span>
<span class="sd">    ``sequence_type`` data of length ``n``.</span>
<span class="sd">    This method handels scores with distributions independent of ``l``. This includes</span>
<span class="sd">    all parsimony scores, and excludes model based scores.</span>

<span class="sd">    The order of the values in the probability density function is WORST FIRST: The first</span>
<span class="sd">    values describe the probability for &quot;bad&quot; scores, the last values the probabilities</span>
<span class="sd">    for &quot;top&quot; scores.</span>

<span class="sd">    Currently, for all models values are available until</span>

<span class="sd">        * ``nMax`` = 150</span>

<span class="sd">    For ``n`` &lt;=  ``nMax`` all values are available. If no distribution is available for</span>
<span class="sd">    a given ``n`` the closest values for ``n`` is used.</span>

<span class="sd">    For values of ``n`` above ``nMax``, the ``nMax`` pdf is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        score: The heuristic model used. E.g. &quot;psim&quot;.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy list of length 10.000</span>

<span class="sd">    .. todo:: Check return type.</span>
<span class="sd">    .. todo:: Check how this method concurs with the ``empiricalList`` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c"># Currently, the pdfs are only save up to nMax = 150</span>
    <span class="n">nMax</span> <span class="o">=</span> <span class="mi">150</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">path_score</span><span class="p">,</span> <span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">nMax</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#39;.txt&#39;</span><span class="p">),</span> <span class="s">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pdf_file</span><span class="p">:</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="s">&#39;excel-tab&#39;</span><span class="p">)]</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>

<span class="c">################################### pSim &amp; parsimony #####################################</span>
</div>
<div class="viewcode-block" id="calculate_repeat_structure"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.calculate_repeat_structure">[docs]</a><span class="k">def</span> <span class="nf">calculate_repeat_structure</span><span class="p">(</span><span class="n">myTR</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Calculate the number of columns with a certain number of gaps for each column in</span>
<span class="sd">    a ``Repeat`` instance.</span>

<span class="sd">    You can use a different null distribution for each column of different length for both</span>
<span class="sd">    the parsimony and the pSim score. Therefore, calculate the structure of the TR before</span>
<span class="sd">    you calculate the null distribution of tandem repeat scores of tandem repeats with</span>
<span class="sd">    the same gap distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        score: The heuristic model used. E.g. &quot;psim&quot;.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        lRepeatStructure (list)</span>
<span class="sd">        nRepeatStructure (int)</span>

<span class="sd">    .. todo:: Include exact definition of returned values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">repeatStructure</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">myTR</span><span class="o">.</span><span class="n">msaTD</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">column</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="n">nRepeatStructure</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">repeatStructure</span><span class="p">))</span>
    <span class="n">lRepeatStructure</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">repeatStructure</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nRepeatStructure</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">lRepeatStructure</span><span class="p">,</span><span class="n">nRepeatStructure</span>


<span class="c">############################ DERIVE p-Value distributions ################################</span>
</div>
<div class="viewcode-block" id="calc_pValues"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.calc_pValues">[docs]</a><span class="k">def</span> <span class="nf">calc_pValues</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">resultFilePath</span><span class="p">,</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">scoreslist</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;phylo&#39;</span><span class="p">,</span><span class="s">&#39;phylo_gap&#39;</span><span class="p">],</span> <span class="n">gappy_data</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Create and save a null distribution for ``repeats`` scores for p-Value calculation.</span>

<span class="sd">    You can use a different null distribution for each column of different length for both</span>
<span class="sd">    the parsimony and the pSim score. Therefore, calculate the structure of the TR before</span>
<span class="sd">    you calculate the null distribution of tandem repeat scores of tandem repeats with</span>
<span class="sd">    the same gap distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        repeats (list of Repeat): A list of ``Repeat`` instances.</span>
<span class="sd">        resultFilePath (str): Path to result folder.</span>
<span class="sd">        fileName (str): Name of result file.</span>
<span class="sd">        scoreslist (list of str):  List of scores. E.g. [&#39;phylo&#39;,&#39;phylo_gap&#39;].</span>
<span class="sd">        gappy_data (bool): True if any of ``repeats`` contain gaps, else False.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># If the repeats are not gappy, than you can use always the same distribution of scores</span>
    <span class="c"># on random data to calculate the p-Value. Otherwise, there might be deletion columns</span>
    <span class="c"># and the distribution should be loaded each time &#39;pValueFromEmpiricialList&#39; is called.</span>
    <span class="n">empirical_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">iScore</span> <span class="ow">in</span> <span class="n">scoreslist</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;parsimony&#39;</span> <span class="o">==</span> <span class="n">iScore</span><span class="p">:</span>
            <span class="n">testStatistic</span> <span class="o">=</span> <span class="p">[</span><span class="n">pValuePars</span><span class="p">(</span><span class="n">iRepeat</span><span class="p">)</span> <span class="k">if</span> <span class="n">iRepeat</span><span class="o">.</span><span class="n">lD</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">iRepeat</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s">&#39;pSim&#39;</span> <span class="o">==</span> <span class="n">iScore</span><span class="p">:</span>
            <span class="n">testStatistic</span> <span class="o">=</span> <span class="p">[</span><span class="n">pValuePSim</span><span class="p">(</span><span class="n">iRepeat</span><span class="p">)</span> <span class="k">if</span> <span class="n">iRepeat</span><span class="o">.</span><span class="n">lD</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">iRepeat</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gappy_data</span><span class="p">:</span>
                <span class="n">empirical_list</span> <span class="o">=</span> <span class="n">empiricalList</span><span class="p">(</span><span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lD</span><span class="p">,</span> <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">repeats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">iScore</span><span class="p">)</span>
            <span class="n">testStatistic</span> <span class="o">=</span> <span class="p">[</span><span class="n">pValueFromEmpiricialList</span><span class="p">(</span><span class="n">iRepeat</span><span class="p">,</span> <span class="n">iScore</span><span class="p">,</span> <span class="n">empirical</span> <span class="o">=</span> <span class="n">empirical_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">iRepeat</span><span class="o">.</span><span class="n">lD</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">iRepeat</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">]</span>
        <span class="n">score_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resultFilePath</span><span class="p">,</span><span class="n">iScore</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">score_path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">score_path</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">score_path</span><span class="p">,</span><span class="n">fileName</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">score_path</span><span class="p">,</span><span class="n">fileName</span><span class="p">)</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">testStatistic</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="dAverageMultinom"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.dAverageMultinom">[docs]</a><span class="k">def</span> <span class="nf">dAverageMultinom</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Helper function for the analytic calculation of parsimony or pSim scores.</span>

<span class="sd">    Called by ``dAverageMultipleMaxMultinom`` or ``dAverageMultipleParsMultinom``.</span>

<span class="sd">    Return the ``l``-times self-convoluted pdf of the score on random sequence_type data</span>
<span class="sd">    of length ``n``. The order of the pdf is kept from ``columnPDF()``.</span>

<span class="sd">    For details see:</span>

<span class="sd">    Schaper, E., Kajava, A., Hauser, A., &amp; Anisimova, M. Repeat or not repeat?</span>
<span class="sd">    --Statistical validation of tandem repeat prediction in genomic sequences.</span>
<span class="sd">    Nucleic Acids Research (2012).</span>

<span class="sd">    Args:</span>
<span class="sd">        l (int): The length of the repeat unit.</span>
<span class="sd">        n (int): The number of repeat units.</span>
<span class="sd">        sequence_type (str): The type of the sequence: either &quot;AA&quot; or &quot;DNA&quot;.</span>
<span class="sd">        score: The model of repeat evolution used. Either &#39;psim&#39; or &#39;parsimony&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (description missing)</span>

<span class="sd">    .. warning:: if precision higher than max(uint32) use uint64 instead.</span>
<span class="sd">            CHECK: http://docs.scipy.org/doc/numpy/user/basics.types.html</span>

<span class="sd">    .. todo:: Describe return value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">completePDF</span> <span class="o">=</span> <span class="n">columnPDF</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="p">,</span> <span class="n">sequence_type</span> <span class="o">=</span> <span class="n">sequence_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">singleColumnPDF</span> <span class="o">=</span> <span class="n">completePDF</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">completePDF</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">completePDF</span><span class="p">,</span> <span class="n">singleColumnPDF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">completePDF</span>

<span class="c">####################################### pSim #############################################</span>

</div>
<div class="viewcode-block" id="dAverageMultipleMaxMultinom"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.dAverageMultipleMaxMultinom">[docs]</a><span class="k">def</span> <span class="nf">dAverageMultipleMaxMultinom</span><span class="p">(</span><span class="n">myTR</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="mf">10000.</span><span class="p">):</span> <span class="c"># python 2: precision must be float</span>

    <span class="sd">&quot;&quot;&quot; Calculate null distribution for e.g. the pSim score for repeats of type ``myTR``</span>
<span class="sd">        as a probability density function.</span>

<span class="sd">    Analytically calculate the p-Value distribution for the pSim score for repeats of</span>
<span class="sd">    type ``myTR``. The derivation is described in:</span>

<span class="sd">    Schaper, E., Kajava, A., Hauser, A., &amp; Anisimova, M. Repeat or not repeat?</span>
<span class="sd">    --Statistical validation of tandem repeat prediction in genomic sequences.</span>
<span class="sd">    Nucleic Acids Research (2012).</span>

<span class="sd">    Args:</span>
<span class="sd">        myTR (Repeat): A ``Repeat`` instance.</span>
<span class="sd">        precision (float): The precision of the returned probability density function in</span>
<span class="sd">        terms of the length of the resulting list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p (list of float): cumulated probabilities from 0 to 1.</span>
<span class="sd">        unnamed (list of float): scores corresponding to the probabilities in ``p``.</span>

<span class="sd">    .. warning:: if precision higher than max(uint32) use uint64 instead.</span>
<span class="sd">            CHECK: http://docs.scipy.org/doc/numpy/user/basics.types.html</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">lRepeatStructure</span><span class="p">,</span><span class="n">nRepeatStructure</span> <span class="o">=</span> <span class="n">calculate_repeat_structure</span><span class="p">(</span><span class="n">myTR</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">dAverageMultinom</span><span class="p">(</span>
        <span class="n">lRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">myTR</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="s">&#39;psim&#39;</span>
    <span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">lRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">]:(</span><span class="n">lRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)]</span>
         <span class="o">*</span> <span class="p">(</span><span class="n">precision</span><span class="o">/</span><span class="n">nRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;uint32&#39;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># return best values first. for pSim, best = 1, worst = 0</span>
        <span class="k">return</span>  <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">precision</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">)):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
                <span class="n">dAverageMultinom</span><span class="p">(</span>
                    <span class="n">lRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">myTR</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="s">&#39;psim&#39;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">lRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">]:(</span><span class="n">lRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">nRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)]</span>
                        <span class="o">*</span> <span class="p">(</span><span class="n">precision</span><span class="o">/</span><span class="n">nRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;uint32&#39;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>


            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
        <span class="c"># return best values first. for pSim, best = 1, worst = 0</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">val</span><span class="o">/</span><span class="p">(</span><span class="n">precision</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">)))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="pValuePSim"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.pValuePSim">[docs]</a><span class="k">def</span> <span class="nf">pValuePSim</span><span class="p">(</span><span class="n">myTR</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Calculate the p-Value of the pSim score for a Repeat.</span>

<span class="sd">    Retrieve the probability density function for repeats of the same type as ``myTR``.</span>
<span class="sd">    Then, calculate the p-Value given this probability density function, and the</span>
<span class="sd">    pSim score of ``myTR``.</span>

<span class="sd">    Args:</span>
<span class="sd">        myTR (Repeat): A ``Repeat`` instance.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p-Value (float)</span>

<span class="sd">    .. todo:: Check the method&#39;s behaviour if ``myTR`` s parsimony score has not been</span>
<span class="sd">        calculated before.</span>
<span class="sd">    .. todo:: Check exception: if pdf == False: return 1.</span>
<span class="sd">    .. todo:: Describe ``precision``.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">precision</span> <span class="o">=</span> <span class="mf">10000.</span>

    <span class="n">pdf</span> <span class="o">=</span> <span class="n">dAverageMultipleMaxMultinom</span><span class="p">(</span><span class="n">myTR</span><span class="p">,</span><span class="n">precision</span><span class="p">)</span>
    <span class="n">cumsumPDF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c">#index = np.where(myTR.score(&#39;pSim&#39;) == pdf[1])[0]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">myTR</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s">&#39;pSim&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">precision</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c">## standard case: score is included in pdf[0]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">cumsumPDF</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">myTR</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s">&#39;pSim&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c">## if pars is not exactly included in list, give back mean of value above</span>
    <span class="c">## and value below (should only occur due to numerical imprecision)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span><span class="p">((</span><span class="n">cumsumPDF</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumsumPDF</span><span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c">## This should only occur if score(&#39;pSim&#39;) is really bad or really good</span>
        <span class="k">return</span> <span class="mi">1</span>

<span class="c">#################################### parsimony #################################</span>

</div>
<div class="viewcode-block" id="dAverageMultipleParsMultinom"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.dAverageMultipleParsMultinom">[docs]</a><span class="k">def</span> <span class="nf">dAverageMultipleParsMultinom</span><span class="p">(</span><span class="n">myTR</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="mf">10000.</span><span class="p">):</span> <span class="c"># python 2: precision must be float</span>

    <span class="sd">&quot;&quot;&quot; Calculate null distribution for the parsimony score for repeats of type ``myTR``</span>
<span class="sd">        as a probability density function.</span>

<span class="sd">    Analytically calculate the p-Value distribution for the parsimony score for repeats of</span>
<span class="sd">    type ``myTR``. The derivation is described in:</span>

<span class="sd">    Schaper, E., Kajava, A., Hauser, A., &amp; Anisimova, M. Repeat or not repeat?</span>
<span class="sd">    --Statistical validation of tandem repeat prediction in genomic sequences.</span>
<span class="sd">    Nucleic Acids Research (2012).</span>

<span class="sd">    Args:</span>
<span class="sd">        myTR (Repeat): A ``Repeat`` instance.</span>
<span class="sd">        precision (float): The precision of the returned probability density function in</span>
<span class="sd">        terms of the length of the resulting list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p (list of float): cumulated probabilities from 0 to 1.</span>
<span class="sd">        unnamed (list of float): scores corresponding to the probabilities in ``p``.</span>

<span class="sd">    .. warning:: if precision higher than max(uint32) use uint64 instead.</span>
<span class="sd">            CHECK: http://docs.scipy.org/doc/numpy/user/basics.types.html</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">lRepeatStructure</span><span class="p">,</span><span class="n">nRepeatStructure</span> <span class="o">=</span> <span class="n">calculate_repeat_structure</span><span class="p">(</span><span class="n">myTR</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">dAverageMultinom</span><span class="p">(</span>
        <span class="n">lRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">myTR</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="s">&#39;parsimony&#39;</span>
    <span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[(</span><span class="n">lRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">nRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mf">1.</span><span class="p">]</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">precision</span><span class="o">/</span><span class="p">(</span><span class="n">nRepeatStructure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1.</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;uint32&#39;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># return best values first. for parsimony, best = 0, worst = 1</span>
        <span class="k">return</span>  <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">val</span><span class="o">/</span><span class="p">(</span><span class="n">precision</span> <span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">)))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
                    <span class="n">dAverageMultinom</span><span class="p">(</span>
                        <span class="n">lRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">nRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">myTR</span><span class="o">.</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="s">&#39;parsimony&#39;</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[(</span><span class="n">lRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">nRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mf">1.</span><span class="p">]</span>
                     <span class="o">*</span> <span class="p">(</span><span class="n">precision</span><span class="o">/</span><span class="p">(</span><span class="n">nRepeatStructure</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">1.</span><span class="p">))</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;uint32&#39;</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s">&quot;Failed on: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">nRepeatStructure</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="c"># return best values first. for parsimony, best = 0, worst = 1.</span>
        <span class="c"># Here, the  np.bincount() and np.unique() funs did the reordering.</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="o">/</span><span class="p">(</span><span class="n">precision</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">lRepeatStructure</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="pValuePars"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.pValuePars">[docs]</a><span class="k">def</span> <span class="nf">pValuePars</span><span class="p">(</span><span class="n">myTR</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Calculate the p-Value of the parsimony score for a Repeat.</span>

<span class="sd">    Retrieve the probability density function for repeats of the same type as ``myTR``.</span>
<span class="sd">    Then, calculate the p-Value given this probability density function, and the</span>
<span class="sd">    parsimony score of ``myTR``.</span>

<span class="sd">    Args:</span>
<span class="sd">        myTR (Repeat): A ``Repeat`` instance.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p-Value (float)</span>

<span class="sd">    .. todo:: Check the method&#39;s behaviour if ``myTR`` s parsimony score has not been</span>
<span class="sd">        calculated before.</span>
<span class="sd">    .. todo:: Check exception: if pdf == False: return 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">precision</span> <span class="o">=</span> <span class="mf">10000.</span>

    <span class="n">pdf</span> <span class="o">=</span> <span class="n">dAverageMultipleParsMultinom</span><span class="p">(</span><span class="n">myTR</span><span class="p">,</span><span class="n">precision</span><span class="p">)</span>
    <span class="c"># Check the following three lines:</span>
    <span class="k">if</span> <span class="n">pdf</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">cumsumPDF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c">#index = np.where(pdf[1] == myTR.score(&#39;parsimony&#39;))[0]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">myTR</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s">&#39;parsimony&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">precision</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c">## standard case: score is included in pdf[0]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">cumsumPDF</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">myTR</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="s">&#39;parsimony&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c">## if pars is not exactly included in list, give back mean of value</span>
        <span class="c">## above and value below (should only occur due to numerical imprecision)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cumsumPDF</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">cumsumPDF</span><span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span> <span class="c">## This should only occur if score(&#39;parsimony&#39;) is really bad</span>
        <span class="k">return</span> <span class="mi">1</span>



<span class="c">####################################### gap penalty #####################################</span>
</div>
<div class="viewcode-block" id="gapPenalty"><a class="viewcode-back" href="../../../repeat.html#tandemrepeats.repeat.repeat_pvalue.gapPenalty">[docs]</a><span class="k">def</span> <span class="nf">gapPenalty</span><span class="p">(</span><span class="n">myTR</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Calculate the gap penalty for a ``Repeat`` given mutation rate ``mu``.</span>

<span class="sd">    Args:</span>
<span class="sd">        myTR (Repeat): A ``Repeat`` instance.</span>
<span class="sd">        mu (float): The mutation rate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Gap penalty (float)</span>

<span class="sd">    .. todo:: Define ``mu`` more precisely.</span>
<span class="sd">    .. todo:: Is this function called from anywhere? In case, consider refactoring.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">((</span><span class="n">mu</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mu</span><span class="p">))</span> <span class="o">**</span> <span class="n">myTR</span><span class="o">.</span><span class="n">nGapStructure</span><span class="p">)</span> <span class="o">*</span> <span class="n">myTR</span><span class="o">.</span><span class="n">pGapStructure</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>


  </body>
</html>